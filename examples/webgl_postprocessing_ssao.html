<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - postprocessing - Screen Space Ambient Occlusion</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #aaa;
        }
    </style>
</head>
<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - screen space ambient occlusion<br/>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <script type="module">

        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';  // Import OrbitControls
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        let container, stats;
        let camera, scene, renderer, controls;
        let composer;
        let model;
        let hemisphereLight, directionalLight, ambientLight;
        let originalMaterials = {};
        let texturesVisible = true;

        init();
        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(250, 100, 0);  // Set initial camera position

            // Initialize OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);  // Set the target for the camera to look at
            controls.enableDamping = true;  // Enable smooth damping (inertia)
            controls.dampingFactor = 0.05;  // Damping factor
            controls.update();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xaaaaaa);

            directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            ambientLight = new THREE.AmbientLight(0xffffff);
            hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
            const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 30);
            scene.add(dirLightHelper);
            const hemiLightHelper = new THREE.HemisphereLightHelper(hemisphereLight, 30);
            scene.add(hemiLightHelper);

            scene.add(directionalLight);
            scene.add(ambientLight);
            scene.add(hemisphereLight);
        

            stats = new Stats();
            container.appendChild(stats.dom);

            const width = window.innerWidth;
            const height = window.innerHeight;

            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Configure SSAO Pass
            const ssaoPass = new SSAOPass(scene, camera, width, height);
            ssaoPass.output = SSAOPass.OUTPUT.SSAO;  // Show only the SSAO effect
            composer.addPass(ssaoPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            // Initialize DRACOLoader and GLTFLoader
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('jsm/libs/draco/');
            dracoLoader.setDecoderConfig({ type: 'js' });

            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

            // Load GLTF model
            loader.load('models/gltf/sponza.glb', (gltf) => {
                model = gltf.scene;
                model.position.set(0, 0, 0);
                model.scale.set(50, 50, 50);

                model.traverse((child) => {
                if (child.isMesh) {
                    originalMaterials[child.uuid] = child.material; // Store original material
                }
            });
                scene.add(model);
            }, undefined, (error) => {
                console.error('An error happened', error);
            });

            // Init GUI
            const gui = new GUI();

            gui.add(ssaoPass, 'debugMode').name('Debug Mode').listen().onChange((value) => {
                ssaoPass.debugMode = value ? true : false;
            });
            gui.add(ssaoPass, 'mouseDebugMode').name('Mouse Debug Mode').listen().onChange((value) => {
                ssaoPass.mouseDebugMode = value ? true : false;
            });


            const lightFolder = gui.addFolder('Lights');
            lightFolder.add(directionalLight, 'visible').name('Directional Light');
            lightFolder.add(ambientLight, 'visible').name('Ambient Light');
            lightFolder.add(hemisphereLight, 'visible').name('Hemisphere Light');
            lightFolder.add(directionalLight, 'intensity').min(0).max(10).step(0.1).name('Directional Light Intensity');
            lightFolder.add(hemisphereLight, 'intensity').min(0).max(10).step(0.1).name('Hemisphere Light Intensity');

            // Add controls to adjust directional light position
            const dirLightPositionFolder = lightFolder.addFolder('Directional Light Position');
            dirLightPositionFolder.add(directionalLight.position, 'x').min(-100).max(100).step(1).name('X Position');
            dirLightPositionFolder.add(directionalLight.position, 'y').min(-100).max(100).step(1).name('Y Position');
            dirLightPositionFolder.add(directionalLight.position, 'z').min(-100).max(100).step(1).name('Z Position');

            // Add controls to adjust directional light rotation (affects direction)
            const dirLightRotationFolder = lightFolder.addFolder('Directional Light Rotation');
            dirLightRotationFolder.add(directionalLight.rotation, 'x').min(-Math.PI).max(Math.PI).step(0.01).name('X Rotation');
            dirLightRotationFolder.add(directionalLight.rotation, 'y').min(-Math.PI).max(Math.PI).step(0.01).name('Y Rotation');
            dirLightRotationFolder.add(directionalLight.rotation, 'z').min(-Math.PI).max(Math.PI).step(0.01).name('Z Rotation');

            // Add controls to adjust hemisphere light position
            const hemiLightPositionFolder = lightFolder.addFolder('Hemisphere Light Position');
            hemiLightPositionFolder.add(hemisphereLight.position, 'x').min(-100).max(100).step(1).name('X Position');
            hemiLightPositionFolder.add(hemisphereLight.position, 'y').min(-100).max(100).step(1).name('Y Position');
            hemiLightPositionFolder.add(hemisphereLight.position, 'z').min(-100).max(100).step(1).name('Z Position');

            // Add controls to adjust hemisphere light rotation (affects how it lights the scene)
            const hemiLightRotationFolder = lightFolder.addFolder('Hemisphere Light Rotation');
            hemiLightRotationFolder.add(hemisphereLight.rotation, 'x').min(-Math.PI).max(Math.PI).step(0.01).name('X Rotation');
            hemiLightRotationFolder.add(hemisphereLight.rotation, 'y').min(-Math.PI).max(Math.PI).step(0.01).name('Y Rotation');
            hemiLightRotationFolder.add(hemisphereLight.rotation, 'z').min(-Math.PI).max(Math.PI).step(0.01).name('Z Rotation');


            lightFolder.close();
         
            const savedOutput = localStorage.getItem('ssaoOutput') || SSAOPass.OUTPUT.Default;

            ssaoPass.output = parseInt(savedOutput, 10);

            gui.add(ssaoPass, 'output', {
                'Default': SSAOPass.OUTPUT.Default,
                'AO Only': SSAOPass.OUTPUT.SSAO,
                'AO + Blur': SSAOPass.OUTPUT.Blur,
                'Depth': SSAOPass.OUTPUT.Depth,
                'Normal': SSAOPass.OUTPUT.Normal
            }).onChange(function (value) { 
                ssaoPass.output = value;
                localStorage.setItem('ssaoOutput', value);
            });


            const savedShaderType = localStorage.getItem('shaderType') || 'Advanced';
            const savedBlurShaderType = localStorage.getItem('blurShaderType') || 'Blur New';

            const shaderOptions = {
                ssaoType: savedShaderType,
                blurType: savedBlurShaderType
            };
            

            gui.add(shaderOptions, 'ssaoType', ['Advanced', 'SSAO Old']).name('AO Type').onChange(function (value) {
                ssaoPass.toggleShader(value);
                localStorage.setItem('shaderType', value);
                updateShaderSettingsGUI(value);
            });

            gui.add(ssaoPass, 'kernelRadius').min(0).max(128);

            const minDistanceControl = gui.add(ssaoPass, 'minDistance').min(0.001).max(0.02).step(0.001).name('Min Distance');
            const maxDistanceControl = gui.add(ssaoPass, 'maxDistance').min(0.01).max(1.0).step(0.01).name('Max Distance');


        let aoPowerControl = null;
        let blurScaleControl = null;
        let advancedControlsFolder = null;

        function updateShaderSettingsGUI(shaderType) {
            if (advancedControlsFolder !== null) {
                advancedControlsFolder.hide();
            }

            if (shaderType === 'Advanced') {
                minDistanceControl.hide();

                if (advancedControlsFolder === null) {
                    advancedControlsFolder = gui.addFolder('Advanced Settings');
                }
                
                maxDistanceControl.name('AO Radius Scale')
                    .min(0.01).max(10.0).step(0.1).setValue(3.0);

                aoPowerControl = advancedControlsFolder.add(ssaoPass, 'aoPower').min(0.1).max(3.0).step(0.1).name('AO Power').onChange(function (value) {
                    ssaoPass.setAOPower(value);
                });

                advancedControlsFolder.add(ssaoPass, 'kernelSize').min(4).max(128).step(1).name('SSAO Kernel Size').onChange(function (value) {
                    ssaoPass.setKernelSize(value);
                });

                blurScaleControl = advancedControlsFolder.add(ssaoPass, 'blurScale').min(0.5).max(3.0).step(0.1).name('Blur Scale').onChange(function (value) {
                    ssaoPass.setBlurScale(value);
                });

                advancedControlsFolder.add(ssaoPass, 'blurSampleCount').min(1).max(15).step(1).name('Blur Sample Count').onChange(function (value) {
                    ssaoPass.setBlurSampleCount(value);
                });

                advancedControlsFolder.show();
            } else if (shaderType === 'SSAO Old') {
                minDistanceControl.show();
                
                maxDistanceControl.name('Max Distance')
                    .min(0.01).max(1.0).step(0.01);

                if (advancedControlsFolder !== null) {
                    advancedControlsFolder.hide();
                }
            }
        }


            gui.add(shaderOptions, 'blurType', ['Blur New', 'Blur Old']).name('Blur Type').onChange(function (value) {
                ssaoPass.toggleBlurShader(value);
                localStorage.setItem('blurShaderType', value);
            });

            updateShaderSettingsGUI(shaderOptions.ssaoType);

            gui.add(ssaoPass, 'enabled');
            gui.add({ toggleTextures }, 'toggleTextures').name('Toggle Textures');
            // gui.add(ssaoPass.ssaoMaterial.uniforms['giMix'], 'value').min(0).max(1).step(0.01).name('GI Mix');

            window.addEventListener('resize', onWindowResize);
        }

        function toggleTextures() {
            texturesVisible = !texturesVisible; // Toggle flag

            model.traverse((child) => {
                if (child.isMesh) {
                    if (!texturesVisible) {
                        child.material = new THREE.MeshLambertMaterial({ color: 0x888888 }); // Gray material for AO view
                    } else {
                        // Restore original material
                        child.material = originalMaterials[child.uuid];
                    }
                }
            });
        }

        function onWindowResize() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            composer.setSize(width, height);

        }

        function animate() {

            stats.begin();
            controls.update();  // Update controls in the animation loop
            render();
            stats.end();

        }

        function render() {

            composer.render();

        }

    </script>
</body>
</html>
